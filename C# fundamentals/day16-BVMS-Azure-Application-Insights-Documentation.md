# BVMS Azure Application Insights - Logging & Monitoring Documentation

## Executive Summary

This document outlines how BVMS (Boating Vessel Management System) implements Azure Application Insights for comprehensive system and application logging. The implementation provides real-time monitoring, diagnostic capabilities, and alerting mechanisms to ensure system health and facilitate rapid issue resolution in production environments.

---

## Table of Contents

1. [Overview](#overview)
2. [Types of Logs](#types-of-logs)
3. [Logging Infrastructure](#logging-infrastructure)
4. [Application Insights Features](#application-insights-features)
5. [Monitoring Dashboard Components](#monitoring-dashboard-components)
6. [Query and Search Capabilities](#query-and-search-capabilities)
7. [Custom Dashboard Development](#custom-dashboard-development)
8. [Alert System](#alert-system)
9. [Developer Responsibilities](#developer-responsibilities)
10. [Access Control and Permissions](#access-control-and-permissions)
11. [Best Practices](#best-practices)

---

## Overview

BVMS uses Azure Application Insights as the central logging and monitoring platform to track system health, API performance, and application behavior across different environments (Dev, Test, Production). The system automatically captures telemetry data and allows developers to add custom application logs for detailed diagnostics.

### Key Benefits

- **Real-time monitoring** of system health and performance
- **Automatic correlation** of requests across the entire application stack
- **Custom query capabilities** using KQL (Kusto Query Language)
- **Alert mechanisms** for proactive issue detection
- **End-to-end request tracking** via correlation IDs

---

## Types of Logs

| Log Type            | Description                                 | Responsibility   | Availability                      |
| ------------------- | ------------------------------------------- | ---------------- | --------------------------------- |
| **System Log**      | Automatically captured by Azure environment | Azure Platform   | Default - No configuration needed |
| **Application Log** | Custom logs written by developers           | Development Team | Requires explicit logging code    |

### System Log Details

- Automatically available when running in Azure environment
- Captures:
  - Failed API requests
  - SQL Server query problems
  - System-level exceptions
  - Infrastructure metrics

### Application Log Details

- Requires developers to write explicit logging statements
- Uses **Serilog** library for .NET applications
- Supports multiple output targets:
  - Console (for local development)
  - File storage
  - Application Insights (for production)

---

## Logging Infrastructure

### Technology Stack

| Component       | Technology                 | Purpose                              |
| --------------- | -------------------------- | ------------------------------------ |
| Logging Library | Serilog                    | Structured logging for .NET          |
| Log Destination | Azure Application Insights | Centralized log storage and analysis |
| Query Language  | KQL (Kusto Query Language) | Custom log queries and analysis      |
| SDK             | Application Insights SDK   | Automatic telemetry collection       |

### Implementation with Serilog

```csharp
// Example: Dependency injection of logger
public class ConsecutiveVoyageService
{
    private readonly ILogger _logger;

    public ConsecutiveVoyageService(ILogger<ConsecutiveVoyageService> logger)
    {
        _logger = logger;
    }

    public void CalculateConsecutiveVoyage()
    {
        _logger.LogInformation("Starting consecutive voyage calculation");
        // Business logic...
        _logger.LogInformation("Consecutive voyage calculation completed");
    }
}
```

### Correlation ID System

Every request from the frontend automatically receives a **Correlation ID** generated by the Application Insights SDK. This ID:

- Tracks the request throughout its lifecycle
- Links frontend request → backend processing → database queries
- Enables end-to-end request tracing
- Can be captured from browser DevTools (Network tab → Request Headers → X-Correlation-ID)

**Use Case**: When a bug occurs, capture the Correlation ID to trace the complete request flow in Application Insights.

---

## Application Insights Features

### Environment Setup

Each environment has a dedicated Application Insights instance:

| Environment | Purpose                     | Access Level                               |
| ----------- | --------------------------- | ------------------------------------------ |
| Development | Local testing and debugging | All developers                             |
| Test        | Integration testing         | QA team and developers                     |
| Production  | Live system monitoring      | Maintenance team and designated developers |

---

## Monitoring Dashboard Components

### 1. Application Map

**Purpose**: Visual overview of system architecture and health

**Features**:

- Displays all application components (APIs, databases, functions)
- Shows request flow between components
- Highlights error rates and performance metrics
- Configurable time ranges (last 12/24 hours, custom)

**Metrics Displayed**:

- Total requests per component
- Error percentages
- Response times
- Health status indicators

**Example Insights**:

```
Voyage API: 700 calls to DB (< 1% error rate)
Master API: 800 calls to DB (4% error rate)
Azure Functions: 100% fail rate (expected - DB connection not configured)
```

### 2. Live Metrics

**Purpose**: Real-time system performance monitoring

**Key Metrics**:

| Metric           | Description                  | Use Case                         |
| ---------------- | ---------------------------- | -------------------------------- |
| Request Rate     | Incoming requests per second | Monitor traffic patterns         |
| Request Duration | Average response time        | Identify performance bottlenecks |
| CPU Usage        | Processor utilization        | Detect resource exhaustion       |
| Memory Usage     | RAM consumption              | Monitor memory leaks             |
| Failed Requests  | Error count in real-time     | Immediate issue detection        |

**Critical Monitoring Scenario**:

> "During incidents where CPU spikes and RAM gradually increases until application crashes, Live Metrics provides immediate visibility to detect and respond to the issue."

### 3. Transaction Search

**Purpose**: Quick elastic search across all logs

**Search Capabilities**:

- Filter by time range
- Search by text/keyword
- Search by Correlation ID
- Filter by request type (GET, POST, etc.)
- Filter by status code

**Example Searches**:

```
- "consecutive" → Find all consecutive calculation requests
- "estimate" → Find all estimate-related operations
- [Correlation ID] → Trace specific request lifecycle
- "error" → Find all error logs
```

**Search Process**:

1. Open Transaction Search
2. Set time range (e.g., last 24 hours)
3. Enter search term or Correlation ID
4. Review matching logs
5. Click individual entries for detailed information

### 4. Failures Dashboard

**Purpose**: Centralized view of application failures

**Information Provided**:

- Total failed requests in time range
- Failure rate percentage
- Most impactful failing APIs
- Exception types and counts
- Failure trends over time

**Use Case**: Identify high-impact APIs requiring optimization or bug fixes.

### 5. Performance Monitoring

**Metrics Available**:

- Response time percentiles (50th, 90th, 95th, 99th)
- Slowest API endpoints
- Database query performance
- Dependency call durations

### 6. Availability Monitoring

**Purpose**: Track overall system health

**Features**:

- Health check endpoint monitoring
- Uptime percentages
- Service availability status
- Multi-region availability (if configured)

---

## Query and Search Capabilities

### KQL (Kusto Query Language)

Application Insights supports custom queries using KQL for advanced log analysis.

#### Example Queries

**1. Find Recent Non-Health Check Requests**

```kql
requests
| where timestamp > ago(15m)
| where name !contains "health"
| where url contains "bvms"
| take 100
```

**2. Monitor Failed Requests by Threshold**

```kql
requests
| where resultCode != "200"
| summarize count() by bin(timestamp, 5m)
| where count_ > 20
```

**3. Find Requests by Correlation ID**

```kql
union requests, dependencies, exceptions, traces
| where operation_Id == "[CORRELATION_ID_HERE]"
| order by timestamp asc
```

### Query Features

| Feature           | Description                                       |
| ----------------- | ------------------------------------------------- |
| AI-Assisted       | AI can generate KQL queries from natural language |
| Custom Dashboards | Save queries as dashboard components              |
| Export Capability | Export results to Excel, CSV                      |
| Scheduling        | Schedule queries to run automatically             |

---

## Custom Dashboard Development

### Built-in Workbooks

Microsoft provides pre-built workbooks for common monitoring scenarios:

- Request analysis
- Performance metrics
- Failure analysis
- User session tracking

### Custom Workbook Example: Request by Location

**Components**:

- Geographic map visualization
- Request count by region
- Custom time range selector

### Custom Application Dashboard

For advanced monitoring needs, developers can build custom dashboards using:

**Requirements**:

- Client ID (from Application Insights)
- Client Secret (from Azure AD)
- Application ID (from Application Insights registration)

**Custom Metrics Display**:

| Metric                | Description                          | Visualization    |
| --------------------- | ------------------------------------ | ---------------- |
| Total Requests        | Count of all requests in time window | Numeric display  |
| Valid Requests        | Successful (200) response count      | Percentage gauge |
| Average Response Time | Mean latency across all requests     | Time chart       |
| Error Rate            | Percentage of failed requests        | Percentage gauge |
| Availability          | System uptime percentage             | Status indicator |
| Memory Usage          | RAM consumption                      | Line graph       |
| CPU Usage             | Processor utilization                | Line graph       |
| Slowest APIs          | Top 10 slowest endpoints             | Table            |

**Example Custom Dashboard Features**:

- Request count vs. response time correlation chart
- Color-coded performance indicators (green = < 1s, yellow = 1-3s, red = > 3s)
- Top 8 most-called APIs
- Error distribution by status code
- Top exceptions with counts
- Recent 100 requests with details
- Auto-refresh every 2 minutes

**Development Approach**:

> "All custom dashboard code can be generated by AI prompting. No manual coding required for basic monitoring dashboards."

---

## Alert System

### Alert Configuration

Alerts can be configured based on various metrics and thresholds.

#### Alert Setup Process

1. **Define Metric**: Choose what to monitor (e.g., failed requests, CPU, memory)
2. **Set Threshold**: Define trigger conditions
3. **Configure Actions**: Specify notification methods
4. **Test**: Review historical data to validate threshold

#### Alert Configuration Example

**Metric**: Failed Requests  
**Condition**: Greater than 20 failures in 5-minute window  
**Actions**:

- Send email notification
- Push notification to Azure mobile app

### Alert Delivery Methods

| Method    | Description                              | Setup Requirements                  |
| --------- | ---------------------------------------- | ----------------------------------- |
| Email     | Send alerts to specified email addresses | Email address list                  |
| Azure App | Push notifications to mobile device      | Azure app installed, account linked |
| Webhook   | HTTP POST to custom endpoint             | Webhook URL configured              |
| Logic App | Trigger Azure Logic App workflow         | Logic App configured                |

### Alert Notification Content

Current default alert includes:

- Event timestamp
- Alert name
- Triggering Application Insights instance
- Metric value that triggered alert
- Link to Application Insights

**Note**: "The default alert format is not ideal - information is scattered. Custom alert templates can be developed for better clarity."

### Advanced Alert Actions

Beyond notifications, alerts can trigger:

- Custom code execution
- Metric aggregations
- Automated remediation scripts
- Integration with ticketing systems

---

## Developer Responsibilities

### Logging Requirements

| Requirement                  | Description                                        | Priority |
| ---------------------------- | -------------------------------------------------- | -------- |
| Increase Log Volume          | Add more application logs throughout codebase      | High     |
| Log Business-Heavy Functions | Log entry/exit and key steps in complex operations | High     |
| Use Structured Logging       | Leverage Serilog's structured logging capabilities | Medium   |
| Include Context              | Add correlation IDs and relevant metadata          | High     |

### Development Best Practices

**1. Add Application Logs**

```csharp
// Log at function entry
_logger.LogInformation("Starting heavy processing: {FunctionName}", nameof(CalculateConsecutiveVoyage));

// Log important milestones
_logger.LogInformation("Processing step 1 completed. Records processed: {Count}", recordCount);

// Log completion
_logger.LogInformation("Heavy processing completed. Duration: {Duration}ms", duration);
```

**2. Log Errors with Context**

```csharp
catch (Exception ex)
{
    _logger.LogError(ex, "Failed to calculate consecutive voyage for VoyageId: {VoyageId}", voyageId);
    throw;
}
```

### Maintenance Rotation

Developers participate in scheduled maintenance rotations to monitor production systems.

**Maintenance Responsibilities**:

| Task                         | Frequency         | Tool                      |
| ---------------------------- | ----------------- | ------------------------- |
| Check Application Map        | Daily             | Application Map dashboard |
| Monitor Live Metrics         | During peak hours | Live Metrics stream       |
| Review Failures              | Daily             | Failures dashboard        |
| Investigate High-Impact APIs | As needed         | Transaction Search + KQL  |
| Respond to Alerts            | Immediate         | Email/Azure App           |

**Monitoring Workflow**:

1. **Check Overall Health**: Review Application Map for error rates
2. **Monitor Live Performance**: Watch Live Metrics for resource usage spikes
3. **Search for Issues**: Use Transaction Search for specific problems
4. **Analyze Failures**: Review Failures dashboard for patterns
5. **Custom Analysis**: Write KQL queries for deep investigation

---

## Access Control and Permissions

### Permission Levels

| Role               | Access Level | Capabilities                                    |
| ------------------ | ------------ | ----------------------------------------------- |
| Log Monitor Reader | Read-only    | View logs and metrics, no configuration changes |
| Contributor        | Read/Write   | View logs, create alerts, modify dashboards     |
| Owner              | Full access  | All capabilities + manage permissions           |

### Access Methods

#### Method 1: Direct Application Insights Access

**Best for**: Maintenance team, DevOps engineers

**Setup**:

1. Add user as "Log Monitor Reader" to Application Insights resource
2. User logs into Azure Portal
3. Navigate to Application Insights instance
4. Access all built-in tools and dashboards

#### Method 2: Custom Dashboard Application

**Best for**: Developers during development

**Setup**:

1. Develop custom monitoring application
2. Register application in Azure AD
3. Configure with Application Insights credentials
4. Share application repository with team
5. Developers run locally with company VPN

**Benefits**:

- Customizable interface
- Team-specific metrics
- Local execution (no public exposure)
- Version controlled (Git repository)

**Access via VPN**:

> "The custom dashboard runs locally but connects to Azure Application Insights. Access requires company VPN (WireGuard) connection."

### Recommended Access Strategy

| User Type                      | Environment | Access Method                      |
| ------------------------------ | ----------- | ---------------------------------- |
| All Developers                 | Development | Direct Application Insights access |
| QA Team                        | Test        | Direct Application Insights access |
| Maintenance Team               | Production  | Direct Application Insights access |
| Developers (Development Phase) | Development | Custom dashboard (optional)        |

---

## Best Practices

### For Developers

1. **Log Generously**: Add logs for all significant operations
2. **Use Appropriate Log Levels**:
   - `Information`: Normal flow, important milestones
   - `Warning`: Recoverable issues, deprecations
   - `Error`: Exceptions, failures
   - `Debug`: Detailed diagnostic information
3. **Include Context**: Always include relevant IDs (userId, voyageId, estimateId)
4. **Avoid Logging Sensitive Data**: Never log passwords, tokens, or PII
5. **Test Locally**: Verify logs appear correctly before deploying

### For Maintenance Team

1. **Regular Monitoring**: Check Application Insights at least twice daily
2. **Correlation ID Tracking**: Always capture Correlation ID when investigating issues
3. **Threshold Awareness**: Know normal baselines for key metrics
4. **Quick Response**: Investigate alerts within 15 minutes
5. **Document Incidents**: Log all significant issues and resolutions

### For System Design

1. **Separate Environments**: Each environment has dedicated Application Insights
2. **Consistent Naming**: Use clear, searchable names in logs
3. **Correlation Strategy**: Ensure Correlation IDs flow through entire stack
4. **Alert Tuning**: Regularly review and adjust alert thresholds
5. **Dashboard Iteration**: Continuously improve monitoring dashboards based on needs

---

## Troubleshooting Workflow

### Incident Response Process

```
1. Alert Triggered / Issue Reported
   ↓
2. Check Live Metrics (Is system currently struggling?)
   ↓
3. Review Application Map (Which component is failing?)
   ↓
4. Transaction Search (Find relevant logs/requests)
   ↓
5. Correlation ID Analysis (Trace complete request flow)
   ↓
6. Custom KQL Query (Deep dive into specific issue)
   ↓
7. Identify Root Cause
   ↓
8. Route to Development Team for Fix
```

### Finding Logs for Specific Request

**Scenario**: User reports a bug in the UI

**Steps**:

1. Reproduce the issue with browser DevTools open
2. Open Network tab and find the failed request
3. Copy the `X-Correlation-ID` header value
4. Go to Application Insights → Transaction Search
5. Paste Correlation ID in search box
6. Review complete request lifecycle:
   - Frontend request initiation
   - Backend API processing
   - Database queries executed
   - Any exceptions or errors
   - Response returned

**Result**: Complete visibility into what happened during that specific user action.

---

## Future Enhancements

### Planned Improvements

1. **Automatic Support Tickets**

   - Capture Correlation ID on frontend errors
   - Automatically create support ticket with full context
   - Route to maintenance team with diagnostic information

2. **User Activity Tracking**

   - Attach User ID to all logs
   - Query all actions by specific user in time range
   - Recreate user journey leading to bug

3. **Custom Log Dashboard Repository**

   - Company-wide repository of monitoring tools
   - Developers can customize for their needs
   - AI-assisted dashboard generation
   - Share monitoring patterns across team

4. **Enhanced Alert System**

   - Custom alert templates with better formatting
   - Integration with ticketing system
   - Automated remediation for common issues
   - Escalation rules based on severity

5. **Mitigation Strategies**
   - Rollback procedures
   - Database revert protocols
   - Quick-fix deployment pipeline
   - Incident response playbooks

---

## Monitoring Scenarios

### Scenario 1: High CPU Usage

**Symptoms**: Live Metrics shows CPU consistently above 80%

**Investigation**:

1. Check Application Map for high request volume
2. Review slowest APIs in Performance dashboard
3. Query for requests during high-CPU period
4. Analyze query patterns and heavy operations
5. Route optimization work to development team

### Scenario 2: Increasing Error Rate

**Symptoms**: Application Map shows rising error percentage

**Investigation**:

1. Check Failures dashboard for error distribution
2. Identify most failing API endpoint
3. Search for error-specific logs
4. Review exception stack traces
5. Check if related to recent deployment
6. Determine if rollback is needed

### Scenario 3: Slow Response Times

**Symptoms**: Average response time exceeds 1 second

**Investigation**:

1. Check database query performance in dependencies
2. Review slowest APIs
3. Analyze correlation between request volume and response time
4. Check for resource constraints (CPU, memory)
5. Identify optimization opportunities

---

## KQL Query Examples

### Find Requests by User (Future Enhancement)

```kql
requests
| where customDimensions.userId == "USER_ID_HERE"
| where timestamp > ago(1h)
| order by timestamp asc
| project timestamp, name, url, resultCode, duration
```

### Top 10 Slowest APIs

```kql
requests
| where timestamp > ago(1h)
| summarize AvgDuration=avg(duration), Count=count() by name
| order by AvgDuration desc
| take 10
```

### Error Distribution

```kql
requests
| where resultCode != "200"
| summarize Count=count() by resultCode
| render piechart
```

### Request Volume Over Time

```kql
requests
| where timestamp > ago(1h)
| summarize Count=count() by bin(timestamp, 5m)
| render timechart
```

---

## Summary

Azure Application Insights provides BVMS with a comprehensive logging and monitoring solution that enables:

- **Proactive Monitoring**: Real-time visibility into system health
- **Rapid Diagnosis**: Quick identification of issues via Correlation IDs
- **Informed Decision-Making**: Rich metrics and custom queries
- **Team Collaboration**: Shared access to logs and dashboards
- **Continuous Improvement**: Data-driven optimization opportunities

### Key Takeaways

| Aspect                | Implementation                       |
| --------------------- | ------------------------------------ |
| **Logging Library**   | Serilog for structured logging       |
| **Central Platform**  | Azure Application Insights           |
| **Request Tracking**  | Automatic Correlation ID per request |
| **Query Language**    | KQL for custom analysis              |
| **Custom Dashboards** | AI-assisted development              |
| **Access Control**    | Role-based permissions               |
| **Alert System**      | Email + Azure App notifications      |
| **Team Practice**     | Rotating maintenance schedule        |

### Success Criteria

- ✅ Developers add comprehensive application logs
- ✅ Maintenance team monitors Application Insights daily
- ✅ Correlation IDs used for all issue investigations
- ✅ Custom dashboards deployed for team-specific needs
- ✅ Alert system configured with appropriate thresholds
- ✅ All team members trained on Application Insights usage

---

## References

- **Azure Application Insights Documentation**: [https://docs.microsoft.com/azure/azure-monitor/app/app-insights-overview](https://docs.microsoft.com/azure/azure-monitor/app/app-insights-overview)
- **KQL Reference**: [https://docs.microsoft.com/azure/data-explorer/kusto/query/](https://docs.microsoft.com/azure/data-explorer/kusto/query/)
- **Serilog Documentation**: [https://serilog.net/](https://serilog.net/)

---

**Document Version**: 1.0  
**Last Updated**: November 13, 2025  
**Based on**: BVMS Logging & Monitoring Training Session Transcript
